% Author : Alexandre Quenon
% Last update : Décembre 2020 by Ibraimovski Roméo

% % % % % % %
%  Packages %
% % % % % % %

%---Base packages
\documentclass[a4paper,12pt]{report}	% document type (article, report, book)
\usepackage[utf8]{inputenc}			% encoding
\usepackage[T1]{fontenc}			% accent
\usepackage{lmodern}				% latin font
\usepackage{appendix}				% to be able to use appendices

%---Language(s)
\usepackage[english,frenchb]{babel}	% last language = typography by default
\addto\captionsfrench{				% to change the french names of...
	\renewcommand{\appendixpagename}{Annexes}	% (default Appendices)
	\renewcommand{\appendixtocname}{Annexes}	% (default Appendices)
	\renewcommand{\tablename}{\textsc{Tableau}}	% (default \textsc{Table})
}

%---Page layout
%------> margins
	% 1st option -> geometry package
		%\usepackage[a4paper]{geometry}		% default parameters for A4
		%\usepackage[top=2in, bottom=1.5in, left=1in, right=1in]{geometry}
	% 2nd option -> a4wide package
		\usepackage{a4wide}		% A4 with smaller margins (the one I've chosen)
	% 3rd option -> fullpage package
		%\usepackage{fullpage}
%------> chapter style
	% 1st option -> fncychap package
		%\usepackage[style]{fncychap}		% style = Lenny, Bjornstrup, Sonny, Conny
	% 2nd option -> customized styles
		%
%------> cover page (UMONS template)
	\usepackage[fs]{umons-coverpage}		% NEED "umons-coverpage.sty" file
	\umonsAuthor{Made by Roméo \textsc{Ibraimovski} \& Maxime \textsc{Nabli}}
	\umonsTitle{Rapport de projet}
	\umonsSubtitle{Exercice préliminaire}
	\umonsDocumentType{S-INFO-820	Projet de structures de données II}
	\umonsSupervisor{Supervised by Gauvain \textsc{Devillez}}
	\umonsDate{3e Bachelier en Sciences Informatiques\\ Année 2021-2022}

%---Numbering
\setcounter{secnumdepth}{2}			% numerotation depth (1=sec and all above)
\setcounter{tocdepth}{2}			% table of contents depth (1=sec and above)

%---Mathematics
\usepackage{amsmath}				% base package for mathematics
\usepackage{amsfonts}				% base package for mathematics
\usepackage{amssymb}				% base package for mathematics
%\usepackage{amsthm}				% theorem and proof environments
%\usepackage{cases}					% numcases environment
%\usepackage{mathrsfs}				% \mathscf command ('L' of Laplace-Transform,...)

%---Floating objects (images, tables,...)
\usepackage{float}					% better management of floating objects
\usepackage{array}					% better management of tables
\usepackage{graphicx}				% to include external images
\graphicspath{{Images/}}			% to put images in an 'Images' folder 
%\usepackage{caption}				% /!\ has priority on "memoir" class
%\usepackage{subcaption}			% subfigure and subtable environments
%\usepackage{subfig}				% \subfloat command
%\usepackage{wrapfig}				% wrapfigure environment
%\usepackage[update]{epstopdf}		% to use '.eps' files with PDFLaTeX

%---Code including
\usepackage{listings}				% general package (can be tuned)
%\usepackage[framed]{mcode}			% to include Matlab code
									% /!\ you need the "mcode.sty" file

%---Units from International System
\usepackage{siunitx}				% \SI{}{} command (units with good typography)
\DeclareSIUnit\baud{baud}			% definition of the "baud" unit
\DeclareSIUnit\bit{bit}				% definition of the "bit" unit

%---Drawing
%\usepackage{tikz}					% useful package for drawing
%\usepackage[european]{circuitikz} 	% to draw electrical circuits

%---Bibliography
\usepackage{url}					% to encore url
\usepackage[style=numeric-comp,backend=bibtex]{biblatex}
\usepackage{csquotes}				% inverted commas in references
%\bibliography{bibli}				% your .bib file

%---"hyperref" package				% /!\ it must be the last package
\usepackage[hidelinks]{hyperref}	% clickable links (table of contents,...)

%Pour écrire des algos: --------------------------------------------------------------------------
\usepackage{algorithmic, algorithm}

%Traduction en français
\floatname{algorithm}{Algorithme}
\renewcommand{\algorithmicrequire}{\textbf{Entrée :}}
\renewcommand{\algorithmicensure}{\textbf{Sortie :}}
\renewcommand{\algorithmicend}{\textbf{Fin}}
\renewcommand{\algorithmicif}{\textbf{Si}}
\renewcommand{\algorithmicthen}{\textbf{Alors}}
\renewcommand{\algorithmicelse}{\textbf{Sinon}}
\renewcommand{\algorithmicelsif}{\algorithmicelse\ \algorithmicif}
\renewcommand{\algorithmicendif}{\algorithmicend\ \algorithmicif}
\renewcommand{\algorithmicfor}{\textbf{Pour}}
\renewcommand{\algorithmicforall}{\textbf{pour tout}}
\renewcommand{\algorithmicdo}{\textbf{Faire}}
\renewcommand{\algorithmicendfor}{\algorithmicend\ \algorithmicfor}
\renewcommand{\algorithmicwhile}{\textbf{Tant que}}
\renewcommand{\algorithmicendwhile}{\algorithmicend\ \algorithmicwhile}
\renewcommand{\algorithmicloop}{\textbf{boucle}}
\renewcommand{\algorithmicendloop}{\algorithmicend\ \algorithmicloop}
\renewcommand{\algorithmicrepeat}{\textbf{répéter}}
\renewcommand{\algorithmicuntil}{\textbf{jusqu'à}}
\renewcommand{\algorithmicprint}{\textbf{imprimer}}
\renewcommand{\algorithmicreturn}{\textbf{Retourner}}
\renewcommand{\algorithmictrue}{\textbf{Vrai}}
\renewcommand{\algorithmicfalse}{\textbf{Faux}}
\renewcommand{\and}{\textbf{Et}}


%Enleve la numérotation des algorithmes
\makeatletter
\renewcommand{\fnum@algorithm}{\fname@algorithm}
\makeatother
%------------------------------------------------------------------------------------------------

% % % % % % %
% Document	%
% % % % % % %

\begin{document}

% Front matter
% ------------
%\frontmatter			% with class "book" only

	\umonsCoverPage		% produce the cover page with UMONS and your Faculty logo
	
	\pagenumbering{roman}	% if you don't use the class "book"
	
	\begin{abstract}	% environment adapted to write the abstract
Ce rapport d'implémentation est rendu dans le cadre de l'AA-S-INFO-820 ``Projet de structure de données II", supervisé par l'Assistant Gauvain Devillez en année académique 2021-2022. Ce rapport a pour but d'expliquer et de justifier nos différents choix de conception.
	\end{abstract}
	
	\clearpage			% to start the toc on a new page
	\tableofcontents
	%\clearpage			% to start the lof on a new page
	%\listoffigures
	%\clearpage			% to start the lot on a new page
	%\listoftables
	

% Main matter
% -----------
%\mainmatter			% with class "book" only

	\clearpage			% if you don't use the class "book"
	\pagenumbering{arabic}
	
	{\section*{Introduction}}
	\addcontentsline{toc}{chapter}{Introduction}	% to add in the toc
\noindent Pour le projet du cours de "Structure de données II", il nous est demandé de résoudre un exercice préliminaire afin de nous familiariser avec la structure de données utilisée pour le projet, les arbres BSP.
\\ \\
\noindent Cet exercice consiste à concevoir un algorithme récursif en pseudo-code prenant en entrée un arbre BSP représentant une scène dans un plan et deux points a et b dans ce plan, et nous renvoie s'il est vrai ou faux que le segment d'extrémités a et b appartient à la scène.
\\ \\
\noindent Dans ce rapport, nous présenterons notre algorithme et ses sous-algorithmes avec leurs explications de fonctionnement ainsi qu'une discussion autour de la complexité de l'algorithme principal.

\newpage
	
	{\section*{1. Algorithme principal}}
	\addcontentsline{toc}{chapter}{1. Algorithme principal}	% to add in the toc

	{\subsection*{1.1 Pseudo-code}}
	\addcontentsline{toc}{section}{1.1 Pseudo-code}	% to add in the toc
	
	\begin{algorithm}
	\caption{$BSPRecherche(T, a, b)$}
	\label{Modele pour un algo}
	\begin{algorithmic} [1]
	\REQUIRE Un arbre BSP T représentant une scène dans un plan (donné par la référence à sa 							racine ou référence vide),  et deux points a et b
	\ENSURE Un booléen (vrai si le segment d'extrémités a et b appartient à la scène,  \\faux sinon)
	\IF{$estVide(T)$}
	\RETURN \FALSE
	\ELSE
	\IF{$listeChaineeRecherche(T_{seg}, a, b)$}
	\RETURN \TRUE
	\ELSE 
	\STATE $bool_a \gets inOpenNegativeHalfSpace(T_{div},a)$
	\STATE $bool_b \gets inOpenNegativeHalfSpace(T_{div},b)$
	\IF{$bool_a = Vrai\ \AND\ bool_b = Vrai$}
	\RETURN $BSPRecherche(T^{-}, a, b)$
	\ELSE
	\IF{$bool_a = Faux\ \AND\ bool_b = Faux$}
	\RETURN $BSPRecherche(T^{+}, a, b)$
	\ELSE
	\STATE $D_{ab} \gets segToLine(a, b)$
	\STATE $c \gets intersection(T_{div}$, $D_{ab})$
	\IF{$bool_a = Vrai\ \AND\ bool_b = Faux$}
	\RETURN $BSPRecherche(T^{-}, a, c)\ \AND\ BSPRecherche(T^{+}, c, b)$
	\ELSE
	\RETURN $BSPRecherche(T^{-}, b, c)\ \AND\ BSPRecherche(T^{+}, c, a)$
	\ENDIF
	\ENDIF
	\ENDIF
	\ENDIF
	\ENDIF
	\end{algorithmic}
	\end{algorithm}
	
	\newpage
	{\subsection*{1.2 Intuition}}
	\addcontentsline{toc}{section}{1.2 Intuition}	% to add in the toc
	
	\noindent Lors de la recherche, en chaque noeud visité, on peut laisser tomber l'un des deux sous-arbre quand le segment se trouve entièrement dans un demi-espace ouvert par rapport à la ligne de subdivision sinon on se retrouve à chercher des segments du segment dans les deux sous-arbres. On suit un chemin de la racine jusqu'à
\begin{itemize}
\item un noeud contenant le segment ou les segments du segment quand celui-ci est présent dans T 
\item ou  une référence vide, quand le segment est absent de T
\end{itemize}

	{\subsection*{1.3 Raisonnement mathématique}}
	\addcontentsline{toc}{section}{1.3 Raisonnement mathématique}	% to add in the toc
	
\noindent 
Cas de base : arbre vide T. Alors le booléen est faux car le segment d'extrémités a et b n'est pas présent\\
Cas général : arbre non vide T de racine v où $T_{div}$ est la droite de subdivision, $T_{seg}$ est une liste chainée des segments inclus dans la ligne de subdivision si v possède au moins un sous arbre non-vide sinon une liste chainée d'un segment seul dans sa partition et $T^{-}$ et $T^{+}$ sont ses sous-arbres
\begin{itemize}
\item Hypothèse : on connait la valeur des booléens retournés par le ou les appels récursifs
\item Si le segment d'extrémités a et b se trouve dans $T_{seg}$, alors le booléen est vrai car on a trouvé le segment
\item Si le segment d'extrémités a et b se trouve entièrement dans un demi-espace négatif ouvert, alors il faut rechercher le segment dans $T^{-}$, et donc le booléen vaudra la valeur retourné par cet appel
\item Si le segment d'extrémités a et b se trouve entièrement dans un demi-espace positif ouvert, alors il faut rechercher le segment dans $T^{+}$, et donc le booléen vaudra la valeur retourné par cet appel
\item Si le segment d'extrémités a et b ne se trouve pas entièrement dans un des demi-espace ouvert, alors il faut trouver le point d'intersection entre le segment et la droite de subdivision et rechercher les segments du segment dans $T^{-}$ et $T^{+}$
\end{itemize}

	
	\newpage

	{\section*{2. Sous-algorithmes}}
	\addcontentsline{toc}{chapter}{2. Sous-algorithmes}	% to add in the toc
	
	{\subsection*{2.1 listeChaineeRecherche(L, a, b)}}
	\addcontentsline{toc}{section}{2.1 listeChaineeRecherche(L, a, b)}	% to add in the toc
	
	\noindent Cet algorithme recherche un segment dans une liste chainée de segment.

	\begin{algorithm}
	\caption{$listeChaineeRecherche(L, a, b)$}
	\label{Modele pour un algo}
	\begin{algorithmic} [1]
	\REQUIRE Une Liste chaînée L de segments de droites dans $R^2$ (donné par la référence de sa tête de liste ou référence vide), et deux points a et b
	\ENSURE Un booléen (vrai si le segment d’extrémités a et b se trouve dans la liste, \\faux sinon)
	\IF{$estVide(L)$}
	\RETURN \FALSE
	\ELSE
	%\STATE $p \gets head$
	\WHILE {$ L \neq vide$}
	\IF{$ inSegment(L_{data}, a, b) = Vrai$}
	\RETURN \TRUE
	\ENDIF
	\STATE $L \gets L_{next}$
	\ENDWHILE
	\RETURN \FALSE
	\ENDIF
	\end{algorithmic}
	\end{algorithm}
	
	\newpage
	
	{\subsection*{2.2 inSegment(s, a, b)}}
	\addcontentsline{toc}{section}{2.2 inSegment(s, a, b)}	% to add in the toc
	
	\noindent Cet algorithme donne l'appartenance d'un segment à un autre segment.
	
	\begin{algorithm}
	\caption{$inSegment(s, a, b)$}
	\label{Modele pour un algo}
	\begin{algorithmic} [1]
	\REQUIRE Un segment s et deux points a et  b de coordonnées $(x_{a}, y_{a})$ et $(x_{b}, y_{b})$
	\ENSURE Un booléen (vrai si le segment d’extrémités a et b est dans le segment s, \\faux sinon)
	\STATE $Récupération\ des\ points\ du\ segments\ et\ des\ coordonnées\ des\ points$
	\STATE $D_{s} \gets segToLine(a_{s}, b_{s})$
	\IF{$a_{D_{s}}*x_{a} + b_{D_{s}}*y_{a} +  c_{D_{s}} = 0\ \AND\  a_{D_{s}}*x_{b} + b_{D_{s}}*y_{b} +  c_{D_{s}} = 0$}
	\STATE $ x_{min} \gets min(x_{a_{s}}, x_{b_{s}})$
	\STATE $ x_{max} \gets max(x_{a_{s}}, x_{b_{s}})$
	\STATE $ y_{min} \gets min(y_{a_{s}}, y_{b_{s}})$
	\STATE $ y_{max} \gets max(y_{a_{s}}, y_{b_{s}})$
	\IF{$ x_{min} \leq x_{a}\ \AND\ x_{a} \leq\ x_{max}\ \AND\  x_{min} \leq x_{b}\ \AND\ x_{b} \leq\ x_{max}\ \newline \AND\ 					y_{min} \leq y_{a}\ \AND\ y_{a} \leq\ y_{max}\ \AND\  y_{min} \leq y_{b}\ \AND\ y_{b} \leq\ y_{max}$}
	\RETURN \TRUE
	\ELSE 
	\RETURN \FALSE
	\ENDIF	
	\ENDIF
	\RETURN \FALSE
	\end{algorithmic}
	\end{algorithm}

	{\subsection*{2.3 inOpenNegativeHalfSpace(D, p)}}
	\addcontentsline{toc}{section}{2.3 inOpenNegativeHalfSpace(D, p)}	% to add in the toc
	
	\noindent Cet algorithme donne l'appartenance d'un point à un demi-espace négatif ouvert par rapport à une droite.

	\begin{algorithm}
	\caption{$inOpenNegativeHalfSpace(D, p)$}
	\label{Modele pour un algo}
	\begin{algorithmic} [1]
	\REQUIRE Une droite D dans $R^2$ représentée par un triplet $(a_{D}, b_{D}, c_{D})$ \\tel que $D \equiv a_{D}*x + b_{D}*y + c_{D} = 0$, un points p de coordonnée $(x_{p}, y_{p})$
	\ENSURE Un booléen (vrai si le point  p se trouve dans le demi-espace négatif ouvert par rapport à D, faux sinon)
	\STATE $Récupération\ du\ triplet\ de\ la\ droite\ D\ et\ des\ composants\ du\ point\ p$
	\IF{$ a_{D}*x_{p} + b_{D}*y_{p} + c_{D} < 0 $}
	\RETURN \TRUE
	\ENDIF
	\RETURN \FALSE
	\end{algorithmic}
	\end{algorithm}
	
	{\subsection*{2.4 segToLine(a, b)}}
	\addcontentsline{toc}{section}{2.4 segToLine(a, b)}	% to add in the toc
	
	\noindent Cet algorithme donne les coefficients de l'équation cartésienne de la droite passant par les deux points.
	
	\begin{algorithm}
	\caption{$segToLine(a, b)$}
	\label{Modele pour un algo}
	\begin{algorithmic} [1]
	\REQUIRE Deux points a et b de coordonnées $(x_{a}, y_{a})$ et $(x_{b}, y_{b})$
	\ENSURE La droite D dans $R^2$ représentée par le triplet $(a_{D}, b_{D}, c_{D})$ \\tel que $D \equiv a_{D}*x + b_{D}*y + c_{D} = 0$, passant par les points a et b
	\STATE $Récupération\ des\ coordonnées\ des\ points$
	\STATE $ vecNorm \gets vecNorm(a, b) $
	\IF{$ a_{n} = 0\ \AND\ b_{n} = 0 $}
	\RETURN $Null$
	\ELSE
	\STATE $ c \gets - a_{n}*x_{a} - b_{n}*y_{a} $
	\STATE $ D \gets [a_{n}, b_{n}, c] $
	\RETURN $D$
	\ENDIF
	\end{algorithmic}
	\end{algorithm}
	
	{\subsection*{2.5 vecNorm(a, b)}}
	\addcontentsline{toc}{section}{2.5 vecNorm(a, b)}	% to add in the toc
	
	\noindent Cet algorithme donne un vecteur normal d'une droite passant par les deux points.
	
	\begin{algorithm}
	\caption{$vecNorm(a, b)$}
	\label{Modele pour un algo}
	\begin{algorithmic} [1]
	\REQUIRE Deux points a et b de coordonnées $(x_{a}, y_{a})$ et $(x_{b}, y_{b})$
	\ENSURE Un vecteur normal d’une droite passant par les points a et b
	\STATE $Récupération\ des\ coordonnées\ des\ points$
	\STATE $ vecDir \gets vecDir(a, b) $
	\STATE $ a_{n} \gets -b_{d} $
	\STATE $ b_{n} \gets a_{d} $
	\STATE $ vecNorm \gets [a_{n}, b_{n}] $
	\RETURN $ vecNorm $
	\end{algorithmic}
	\end{algorithm}
	
		\newpage

	{\subsection*{2.6 vecDir(a, b)}}
	\addcontentsline{toc}{section}{2.6 vecDir(a, b)}	% to add in the toc
	
	\noindent Cet algorithme donne un vecteur directeur d'une droite passant par les deux points.

	\begin{algorithm}
	\caption{$vecDir(a, b)$}
	\label{Modele pour un algo}
	\begin{algorithmic} [1]
	\REQUIRE Deux points a et b de coordonnées $(x_{a}, y_{a})$ et $(x_{b}, y_{b})$
	\ENSURE Un vecteur directeur d’une droite d'équation inconnue passant par \\les points a et b
	\STATE $Récupération\ des\ coordonnées\ des\ points$
	\STATE $ a_{d} \gets x_{a} - x_{b} $
	\STATE $ b_{d} \gets y_{a} - y_{b} $
	\STATE $ vecDir \gets [a_{d}, b_{d}] $
	\RETURN $ vecDir $
	\end{algorithmic}
	\end{algorithm}
		
	{\subsection*{2.7 intersection(D1, D2)}}
	\addcontentsline{toc}{section}{2.7 intersection(D1, D2)}	% to add in the toc
	
	\noindent Cet algorithme donne le point d'intersection des deux droites sécantes.
	
	\begin{algorithm}
	\caption{$intersection(D1, D2)$}
	\label{Modele pour un algo}
	\begin{algorithmic} [1]
	\REQUIRE Deux droites D1 et D2 sécantes dans $R^2$ chacune représentée \\par un triplet $(a_{D}, b_{D}, c_{D})$ tel que $D \equiv a_{D}*x + b_{D}*y + c_{D} = 0$
	\ENSURE Le point p d'intersection des deux droites
	\STATE $Récupération\ des\ triplets\ des\ droite.$
	\STATE $ n_{1} \gets b_{D1}*c_{D2} - b_{D2}*c_{D1}$	
	\STATE $ n_{2} \gets a_{D2}*c_{D1} - a_{D1}*c_{D2}$
	\STATE $ d \gets a_{D2}*b_{D1} - a_{D1}*b_{D2}$
	\STATE $ x_{p} \gets n_{1} / d$
	\STATE $ y_{p} \gets n_{2} / d$
	\STATE $ p \gets [x_{p}, y_{p}]$
	\RETURN $ p $
	\end{algorithmic}
	\end{algorithm}
	
\noindent Remarque : On ne prends pas en compte le parallélisme car 
\begin{itemize}
\item Si la droite associée au segment est parallèle jointe à la droite de subdivision, alors nous sommes dans le cas de où le segment se trouve dans $T_{seg}$ à la racine
\item Si la droite associée au segment est parallèle disjointe à la droite de subdivision, alors nous sommes dans le cas de où le segment est entièrement compris dans un demi-espace ouvert et n'a donc pas besoin d'être segmenté
\end{itemize}

\newpage

	{\section*{3. Complexité}}
	\addcontentsline{toc}{chapter}{3. Complexité}	% to add in the toc
	
\noindent Le pire cas se produit quand on suit le chemin le plus long possible pour un segment d'extrémités a et b absent de T. Il y a un cas un peu plus pire, c'est si l'aglorithme se met à chercher les segments du segment en plus absent.
\begin{itemize}
\item Nombre de noeuds visités : n où n est le nombre de noeud de T
\item Coût local par noeud : en O(l) car
\begin{itemize}
\item Les affectation, tests et appels de fonction effectuant du calcul en temps constant. Tout est en O(1)
\item La recherche dans une liste chainée est en O(l) où l est le nombre d'élément de la liste (relativement petit en pratique)
\item Retour d'un booléen en O(1)
\end{itemize}
\item Nombre de références vides visitées : n + 1
\item Coût local par référence vide : en O(1) car
\begin{itemize}
\item Le test estVide(T) en O(1)
\item Retour de faux en O(1)
\end{itemize}
\end{itemize}
Au total algorithme linéaire en n : n*O(l) + (n + 1)*O(1) = O(l*n) + O(n + 1) = O(l*n)
			
	{\section*{Conclusion}}
		\addcontentsline{toc}{chapter}{Conclusion}	% to add in the toc	
	
\noindent Cet exercice préliminaire nous a permis de nous familiariser avec les arbres BSP, la structure de données principalement utilisée pour le projet. Et donc de nous préparer à la suite du projet.

	
	% Appendices
	%\clearpage
	%\appendix		% Changes the numbering of chapters to an alphabetic form and
					% also changes the names of chapters from \chaptername 
					% to the value of \appendixname.
	%\addappheadtotoc	% Makes an entry in the ToC
	%\appendixpage	% Generates a part-like page with the title given by
					% the value of \appendixpagename. 
	
	%\chapter{The first appendix}
	
		


% Back matter
% -----------
%\backmatter			% with class "book" only
	
	% Bibliography
		%\clearpage			% if it does'nt start on a new page
		%\phantomsection	% if any problem with the reference in the toc
	\printbibliography
	%\addcontentsline{toc}{chapter}{Bibliographie}

\end{document}
