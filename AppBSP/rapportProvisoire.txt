Introduction:

Dans le cadre des cours de "Structure de Données I" et "Structure de Données II" , nous avons vu les arbres binaires et
d'autres structure de données étant des variantes de ces Arbres. Pour ce projet du cours de "Structure de Données II",
nous avons du implémenter les "Binary Search Partition Tree", notés Arbres BSP pour le reste de ce rapport, structure de données
modelée après les arbres binaires. Ces Arbres BSP sont utilisés en géométrie pour représenter les objets contenus dans un plan.
Avec une droite, on coupe ce plan en 2 sous-plans, aussi appelés demi-espace ouvert positif ou négatif (Si la droite coupe un objet,
cet objet est divisé en 2 fragments: un par sous-plan.)
et, nous répétons cette action dans chacun des sous-plan crée jusqu'à ce qu'il ne reste qu'un fragment d'objet par sous-plan.
Les noeuds internes de l'arbre représentent les droites coupant le plan et les sous-plans, les feuilles sont les fragments d'objets.
Pour notre projet, les objets sont des segments de droites et donc, en une dimension. Dans ce cas la, certains segments
peuvent se retrouver contenu dans les droites de coupes. Si cela arrive, nous pouvons retrouver ces segments dans une liste
associée au noeud de la droite.

Ces arbres BSP servent à effectuer l'algorithme du peintre, qui permet d'afficher graphiquement ce que voit une personne d'un certain point de vue par
rapport au plan.

1) Géométrie:
    Nous avons tout d'abord commencé par implémenter l'aspect géométrique de l'application.

- 1.1) Les Points (Classe Point)
    Base de tous les objets géométrique que l'on a besoin, un point est composé de 2 doubles x et y représentant ses coordonnées.

- 1.2) Les Segments (Classe Segment)
    Les Segments sont composés de 2 points, les extrémités, et de la couleur du segment. On peut en calculer la longueur, on peut le diviser en deux,
    et on peut le transformer en droite.

- 1.3) Les Vecteurs (Classe Vector)
    Les Vecteurs sont composé de deux doubles x et y. On peut le construire soit avec un couple de double, soit avec un couple de points.
    On peut calculer leur norme, leur opposer, en additionner, en soustraire et en multiplier par des scalaires.

- 1.4)  Les Droites (Classe Line)
    Une droite dans le plan d'équation αx² + βx + γ = 0. α, β et γ étant des doubles. On peut calculer son intersection avec une autre droite, savoir si un
    segment se trouve à droite ou à gauche de cette droite, et avoir la liste des segments confondus à cette droite.

2) Les Arbres BSP (Classe BSPtree)
    Pour construire un arbre BSP, on a besoin d'une liste de segments , d'une droite de coupe et de deux sous-arbres gauche et droite. La droite de coupe
    est choisie selon l'heuristique utilisée. On peut calculer sa hauteur et le nombre de noeud contenu dans l'arbre.

- 2.1) La Distribution des Segments (Classe SegmentDistribution)
    Quand on a la liste des segments et la droite de coupe, nous pouvons grace aux méthodes dans la classe Line récupérer deux ArrayList de segments,
    ceux contenus dans le demi-espace positif et ceux contenus dans le demi-espace négatif.

- 2.2) La Construction des sous-arbres gauche et droite
    Grace aux ArrayList obtenues, on construit récursivement les sous-arbres.

3) Les Heuristiques
    Pour choisir la droite de coupe utilisée pour construire notre arbre, nous devons utliser une heuristique. Dans le cadre du projet,
    nous avons du implémenter 3 heuristiques. Pour ce faire, nous avons utilisé les Interfaces de Java

- 3.1) L'Heuristique aléatoire
    Cette heuristique prend un segments aléatoire parmis la liste des segments et l'utilise.

- 3.2) L'Heuristique standard
    Cette heuristique prend le premier segment de la liste et l'utilise.

- 3.3) L'Heurisitique TWNB (Abréviation des auteurs de cette heuristique)
    Cette heuristique choisit le segment qui maximise la fonction suivante:
    (fd+)*(fd-) - w*(fd)
    fd+ correspond au nombre de segments dans le demi-espace ouvert positif, fd- au nombre de segments dans le demi-espace ouvert négatif,
    fd au nombre de segments intersectés par la droite et w par un poids à fixer. Après uné série de tests, nous avons choisi un poids de 7.

    On commence par prendre le premier segment de la liste que l'on ajoute dans une liste de segments déjà utilisés. On ajoute aussi à cette liste
    tous les segments se trouvant sur la droite. Ensuite, on calcule le nombre de segments dans ses demis-espaces ouverts positif et négatif via
    des méthodes de la Classe Line, et ensuite on calcule la liste des segments intersectés par cette droite et on effectue le calcul de la fonction
    notée ci-dessus et, on garde en mémoire le ratio des segments. On prend le nombre de segments à gauche que l'on divise par le nombre de segments
    à droite pour savoir combien de fois on a à gauche ce que l'on a a droite.

    Ensuite, on prend le reste des segments dans l'ordre.
    Premièrement: On va regarder si ils ne sont pas déjà dans la liste des segments utilisés. Si il l'est, on passe au segment suivant.
    Deuxièmement: On calcule le ratio des segments. Si on a un ratio plus petit que le segment gardé en mémoire,
    on passe à l'étape suivante sinon, on ajoute le segments et tous les segments confondus à sa droite dans la liste des segments déjà utilisés et
    on passe au segment suivant. On veut équilibrer le nombre de segments de chaque côté.
    Troisièmement: On calcule le nombre de segments intersectés par la droité crée par le segment actuel. Si on a moins de segments intersectés,
    on passe à l'étape suivante sinon, on ajoute le segments et tous les segments confondus à sa droite dans la liste des segments déjà utilisés et
    on passe au segment suivant. On veut minimiser le nombre d'intersection.
    Enfin, on calcule le résultat de la foncion. Si ce résultat est plus petit, on garde le segment, son ratio et le résultat en mémoire,
    on ajoute le segments et les segments confondus a la liste des segmens utilisés et on passe au segment suivant.
    Sinon, on ajoutes les segments et on passe au suivant.

    Dans le pire des cas, aucun segment ne se trouve sur la même droite qu'un autre, chaque segment a un ratio plus petit que le précédent
    et est intersecté par moins de segments que le précédent.
    Pour chaque segment, on parcout 2 fois la liste de segments. Une fois pour faire le ratio et une fois pour les intesection. Par segment,
    la complexité est en O(n²). Et, comme on doit parcourir la liste entièrement, on doit faire n fois l'opération, donc la complexité
    de cet algorithhme est en O(n^3).

- 3.4) Comparaison des différentes heuristiques:


4) Algorithme du Peintre:

4.1) Interface Paintable

5) Applications

- 5.1) Lecture des fichiers texte représentant une scene (Classe SceneReader)
    Notre SceneReader est un objet prenant en paramètre un fichier et le parcours deux fois. D'abord pour vérifier qu'il soit au bon format
    et ensuite pour le lire.
    On commence par regarder si la première ligne contient bien 3 entiers, le premier représentant la limite de l'axe des abscisses, le deuxième
    représentant la limite de l'axe des ordonnées et le troisième représentant le nombre de segments contenus dans le fichier.
    Ensuite, on parcourtle reste du fichier. A chaque ligne, on vérifier que les 4 premiers éléments dont bien des doubles, ensuite
    que l'on a bien une couleur valide de l'application. Et pour terminer, on compte chaque ligne pour vérifier que l'on a bien le bon nombre de segments
    annoncé. Si le fichier n'existe pas ou n'a pas le bon format, la taille de sa liste de segments, la limite en X et la limite en Y sont à 0.
    C'est cela que nous utiliseront par la suite dans le mode console et interactif pour "fermer" l'application.

    Ensuite, pour la lecture du fichier, on stocke les 3 entiers de la première ligne et, à chaque ligne, on crée le segment correspondant
    avant de l'ajouter a la liste des segments du fichier.

- 5.2) Mode Console (Class TestConsole):

    - 5.2.1) Implémentation
        On a commencé par imprimer un message de bienvenue dans la console et proposer un choix du type de scene à écrire dans l'invite de commande.
        On récupère le choix de l'utilisateur avec un Scanner. Si l'utilisateur entre autre chose que les choix proposés, un fichier par défaut sera
        utilisé: le fichier randomHuge.
        En utilisant un switch sur le choix fait par l'utilisateur, on arrive à l'étape suivante: le choix de la taille de la scene.
        Comme précedemment, on récupère le choix de l'utilisateur via un scanner et utilisons un switch pour récupérer le path vers le fichier choisi.
        Pour les fichiers fournit par les enseignants, le path est déjà prêt dans le code. Pour un fichier ajouté manuellement, il y a d'abord la vérification
        de la conformité et ensuite, si il ne l'est pas, l'application est quittée.
        Pour terminer, on imprime quelques informations sur la scene choisie: Son nom, son nombre de segments et la limite de ses axes avant de construire
        les arbres à partir des différentes heuristiques. Pour chacune d'entre elle, on construit l'arbre et récupérons le temps CPU necessaire pour
        sa construction grace à la classe Instant de Java, ensuite nous faisons la même chose en effectuant l'algorithme du peintre.
        Lorsque toutes les heuristiques ont été faites et que toutes les informations sont regroupées dans un tableau dans la console,
        on peut soit relancer le même fichier, soit relancer avec un autre fichier, soit quitter l'application. Si l'utilisateur entre autre chose,
        l'application se fermera.

    - 5.2.2) Guide d'utilisation
        - Lancer TestConsole.
        - Choisir un type de fichier parmi ceux proposés , ou entrer le path vers un fichier externe ajouté via l'invite de commande.
        - Si un type de fichier à été choisi, choisir sa taille via l'invite de commande.
        - Recommencer ou non.


- 5.3) Mode Interactif:

    - 5.3.1) Implémentation

    - 5.3.2) Guide d'utilisation




Conclusion: